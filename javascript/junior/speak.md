
@ let, const, var : в чем отличие?
const   -   можно менять ссылки внутри объекта. Но если мы говорим про
            примитивы, то их, мы предположительно менять не собираемся.

var     -   одна переменная var могла перезаписать другую и не вылезит 
            ошибка, что такой идентификатор определен.

@ Типы данных мутабельные и иммутабельные
        Все типы данных кроме объектов являются иммутубельными

@ Сколько типов данных   
        - 8 типов данных
        number, bigint, string, boolean, null, undefined, object, symbol

@ Операторы сравнения
        ==  - не отличает 0 от false
        === - проверяет равенство без приведения типов

@ Область видимости есть:
        - Глобальная область видимости — переменные и функции, объявленные в глобальном пространстве имен

        - Функциональная область видимости (область видимости функции) — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции.

        - Блочная область видимости — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ })

@ apply, call, bind
        func.apply(obj, [a, b, c, d]) - сразу вызовет функцию
        func.call(obj, a, b, c, d)
        const x = func.bind(obj)

@ i++ || ++i
        i++ - возвращает текущий счетчик и увеличивает
        ++i - увеличивает и возвращает текущий счетчик 

@ forEach и map отличия
        forEach - мутирует массив
        map - возвращает новый

@ Event Loop
        Весь синхронный код последовательно попадает в Call Stack,
        и выполняется
        Все события изначально регистрируются в Web Apis
        и хранятся там
        После запроса или возникновения события - код 
        попадает в Call Queue. Это может быть массив событий, в котором 
        код выполняется и выбрасывает в Call Stack

@ Event Propagation
        При событии(клик на кнопку), событие проходит от window до
        самого глубокого элемента проходя через document, html... и до самого event.traget(вызвавшего элемента)

@ Промисы
        Нужны для упращения работы с асинхронными операциями
        Чтоб не создавать множество колбэков в виде огромных вложенностей

@ prototype
        __proto__  - для чтения
        prototype  - для записи
        Это один из способов обмена свойствами и функциональностью между объектами. Функция toString - не вернет ошибку
        const o = {}
        o.toString()    :[Object object]

@ currentTarget и event.target / в чем разница
        event.target - элемент в котором происходит событие

        currentTarget - элемент, к которому прикреплен слушатель событий.
        При нажатии на дочерние элементы, возвращаеть будет родительский
        элемент, на котором прикреплен слушатель

@ IIFE (Immediatly Invoked Function Expression)
        Фукнция, которая выполняется сразу же, после того как она была 
        определена. Благодаря IIFE переменные замыкаются в пределах области видимости, и глобальная область видимости ими не засоряется.   
        <!--?    (function () {         -->
        <!--?         statements        -->
        <!--?     })();                 -->

@ Ложные значения в JS
        <!-- !   '', 0, null, undefined, NaN, false      --->

@ Директива «use strict»
        «use strict» — это директива ES5, которая заставлвяет
        наш код выполняться в строгом режиме.

        Запрещено присваивать значения глобальный переменным
        Запрещено дублирование параметров
        Значением «this» по умолчанию является undefined:
        и другие

@ Функциональное программирование
        Паттерн того, как строятся приложения
        Метод, в котором используются функции,которые вычисляют значения без изменения аргументов, которые им передаются 
        (filter, map, reduce)
        Замыкания и функции высшего порядка(HOF) - являются характеристиками 
        функционального программирования

@ Как создать объект не имеющий prototype?
        const o2 = Object.create(null)

@ Как определить наличие свойства в объекте?
const o = {
    'prop': 'bwahahah',
    'prop2': 'hweasa'
}
console.log('prop' in o) // true  проверяет свойство также в прототипах
console.log(o.hasOwnProperty('prop2')) // true проверяет только в объекте
console.log(o['prop']) // bwahahah

